// Generated by CoffeeScript 1.6.3
var EventEmitter, HTTP, ProxyRequest, ProxyResponse, Stream, URL, assert, clone, nextTick,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

assert = require("assert");

EventEmitter = require("events").EventEmitter;

HTTP = require("http");

Stream = require("stream");

URL = require("url");

if (typeof setImmediate === 'function') {
  nextTick = setImmediate;
} else {
  nextTick = process.nextTick;
}

ProxyRequest = (function(_super) {
  __extends(ProxyRequest, _super);

  function ProxyRequest(options, replay, proxy) {
    var host, n, port, protocol, v, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    this.replay = replay;
    this.proxy = proxy;
    this.method = (options.method || "GET").toUpperCase();
    _ref = (options.host || options.hostname).split(":"), host = _ref[0], port = _ref[1];
    protocol = options.protocol || "http:";
    port = options.port || port || (protocol === "https:" ? 443 : 80);
    this.url = URL.parse("" + protocol + "//" + (host || "localhost") + ":" + port + (options.path || "/"));
    this.path = this.url.path;
    this.headers = {};
    if (options.headers) {
      _ref1 = options.headers;
      for (n in _ref1) {
        v = _ref1[n];
        this.headers[n.toLowerCase()] = v;
      }
    }
  }

  ProxyRequest.prototype.setHeader = function(name, value) {
    assert(!this.ended, "Already called end");
    assert(!this.body, "Already wrote body parts");
    return this.headers[name.toLowerCase()] = value;
  };

  ProxyRequest.prototype.getHeader = function(name) {
    return this.headers[name.toLowerCase()];
  };

  ProxyRequest.prototype.removeHeader = function(name) {
    assert(!this.ended, "Already called end");
    assert(!this.body, "Already wrote body parts");
    return delete this.headers[name.toLowerCase()];
  };

  ProxyRequest.prototype.setTimeout = function(timeout, callback) {
    this.timeout = [timeout, callback];
  };

  ProxyRequest.prototype.setNoDelay = function(nodelay) {
    if (nodelay == null) {
      nodelay = true;
    }
    this.nodelay = [nodelay];
  };

  ProxyRequest.prototype.setSocketKeepAlive = function(enable, initial) {
    if (enable == null) {
      enable = false;
    }
    this.keepAlive = [enable, initial];
  };

  ProxyRequest.prototype.write = function(chunk, encoding) {
    assert(!this.ended, "Already called end");
    this.body || (this.body = []);
    this.body.push([chunk, encoding]);
  };

  ProxyRequest.prototype.end = function(data, encoding) {
    var _this = this;
    assert(!this.ended, "Already called end");
    if (data) {
      this.write(data, encoding);
    }
    this.ended = true;
    this.proxy(this, function(error, captured) {
      return process.nextTick(function() {
        var response;
        if (error) {
          return _this.emit("error", error);
        } else if (captured) {
          response = new ProxyResponse(captured);
          _this.emit("response", response);
          return response.resume();
        } else {
          error = new Error("" + _this.method + " " + (URL.format(_this.url)) + " refused: not recording and no network access");
          error.code = "ECONNREFUSED";
          error.errno = "ECONNREFUSED";
          return _this.emit("error", error);
        }
      });
    });
  };

  ProxyRequest.prototype.abort = function() {};

  return ProxyRequest;

})(HTTP.ClientRequest);

clone = function(object) {
  var result, x, y;
  result = {};
  for (x in object) {
    y = object[x];
    result[x] = y;
  }
  return result;
};

ProxyResponse = (function(_super) {
  __extends(ProxyResponse, _super);

  function ProxyResponse(captured) {
    this.httpVersion = captured.version || "1.1";
    this.statusCode = captured.status || 200;
    this.headers = clone(captured.headers);
    this.trailers = clone(captured.trailers);
    this._body = captured.body.slice(0);
    this.readable = true;
    this.connection = new EventEmitter();
  }

  ProxyResponse.prototype.pause = function() {
    return this._paused = true;
  };

  ProxyResponse.prototype.resume = function() {
    var _this = this;
    this._paused = false;
    return nextTick(function() {
      var chunk, part;
      if (_this._paused || !_this._body) {
        return;
      }
      part = _this._body.shift();
      if (part) {
        if (_this._encoding) {
          chunk = new Buffer(part).toString(_this._encoding);
        } else {
          chunk = part;
        }
        _this.emit("data", chunk);
        return _this.resume();
      } else {
        _this._body = null;
        _this.readable = false;
        _this._done = true;
        return _this.emit("end");
      }
    });
  };

  ProxyResponse.prototype.setEncoding = function(_encoding) {
    this._encoding = _encoding;
  };

  ProxyResponse.notFound = function(url) {
    return new ProxyResponse({
      status: 404,
      body: ["No recorded request/response that matches " + (URL.format(url))]
    });
  };

  return ProxyResponse;

})(Stream);

module.exports = ProxyRequest;
