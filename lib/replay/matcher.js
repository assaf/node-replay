// Generated by CoffeeScript 1.6.3
var Matcher, URL, assert, jsStringEscape;

assert = require("assert");

URL = require("url");

jsStringEscape = require("js-string-escape");

Matcher = (function() {
  function Matcher(request, response) {
    var headers, name, trailers, url, value, _ref, _ref1, _ref2;
    assert(request.url || request.regexp, "I need at least a URL to match request to response");
    if (request.regexp) {
      this.hostname = request.hostname;
      this.regexp = request.regexp;
    } else {
      url = URL.parse(request.url);
      this.hostname = url.hostname;
      this.port = url.port;
      this.path = url.path;
      this.query = url.query;
    }
    this.method = (request.method && request.method.toUpperCase()) || "GET";
    this.headers = {};
    if (request.headers) {
      _ref = request.headers;
      for (name in _ref) {
        value = _ref[name];
        this.headers[name.toLowerCase()] = value;
      }
    }
    this.body = request.body;
    this.response = {
      version: response.version || "1.1",
      status: response.status && parseInt(response.status, 10) || 200,
      headers: {},
      body: [],
      trailers: {}
    };
    if (response.headers) {
      headers = this.response.headers;
      _ref1 = response.headers;
      for (name in _ref1) {
        value = _ref1[name];
        headers[name.toLowerCase()] = value;
      }
    }
    if (Array.isArray(response.body)) {
      this.response.body = response.body.slice(0);
    } else if (response.body) {
      this.response.body = [response.body];
    }
    if (response.trailers) {
      trailers = this.response.trailers;
      _ref2 = response.trailers;
      for (name in _ref2) {
        value = _ref2[name];
        trailers[name.toLowerCase()] = value;
      }
    }
  }

  Matcher.prototype.match = function(request) {
    var body, chunks, data, headers, method, name, url, value, _i, _len, _ref;
    url = request.url, method = request.method, headers = request.headers, body = request.body;
    if (this.hostname && this.hostname !== url.hostname) {
      return false;
    }
    if (this.regexp) {
      if (!this.regexp.test(url.path)) {
        return false;
      }
    } else {
      if (this.port && this.port !== url.port) {
        return false;
      }
      if (this.path && this.path !== url.path) {
        return false;
      }
      if (this.query && this.query !== url.query) {
        return false;
      }
    }
    if (this.method !== method) {
      return false;
    }
    _ref = this.headers;
    for (name in _ref) {
      value = _ref[name];
      if (value !== headers[name]) {
        return false;
      }
    }
    if (body) {
      data = "";
      for (_i = 0, _len = body.length; _i < _len; _i++) {
        chunks = body[_i];
        data += chunks[0];
      }
      data = jsStringEscape(data);
      if (this.body && this.body !== data) {
        return false;
      }
    }
    return true;
  };

  Matcher.fromMapping = function(host, mapping) {
    var matcher, request;
    assert(!!mapping.path ^ !!mapping.request, "Mapping must specify path or request object");
    if (mapping.path) {
      request = {
        url: URL.resolve("http://" + host + "/", mapping.path),
        method: mapping.method
      };
    } else {
      if (mapping.request.url instanceof RegExp) {
        request = {
          host: host,
          regexp: mapping.request.url,
          method: mapping.request.method,
          headers: mapping.request.headers,
          body: mapping.request.body
        };
      } else {
        request = {
          url: URL.resolve("http://" + host + "/", mapping.request.url),
          method: mapping.request.method,
          headers: mapping.request.headers,
          body: mapping.request.body
        };
      }
    }
    matcher = new Matcher(request, mapping.response || mapping);
    return function(request) {
      if (matcher.match(request)) {
        return matcher.response;
      }
    };
  };

  return Matcher;

})();

module.exports = Matcher;
